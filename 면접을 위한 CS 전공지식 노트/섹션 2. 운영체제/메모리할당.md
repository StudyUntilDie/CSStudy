## **메모리 영역**

- **OS 상주 영역**
  - 낮은 주소 영역 사용
- **사용자 프로세스 영역**
  - 높은 주소 영역 사용
  - 할당 방법
    - 연속 할당
    - 불연속 할당

## **연속 할당**

#### **고정분할 방식**

- 물리적 메모리를 몇 개의 영구적 분할(파티션)으로 나눠놓음
- 분할의 크기가 모두 동일한 방식이 있고 서로 다른 방식이 있다
- 분할 당 하나의 프로그램 적재
- 융통성이 없음
  - 동시에 메모리에 로드되는 프로그램의 수가 고정됨
  - 최대 수행 가능 프로그램 크기 제한
- 내부 조각(내부 단편화), 외부 조각(외부 단편화) 발생
  - 내부 조각은 분할 크기보다 프로그램 크기가 작을 경우 낭비되는 메모리
  - 외부 조각은 분할 크기보다 프로그램 크기가 커 해당 분할을 건너뛰어 낭비되는 메모리

#### **가변분할 방식**

- 프로그램 크기를 고려해서 순서대로 할당
- 분할의 크기, 개수가 동적으로 변한다
- 기술적인 관리 기법이 필요하다
- 외부 조각 발생
  - 기존 프로그램이 종료되었을 때 그 분할의 크기보다 새로운 프로그램의 크기가 더 클 경우
- 할당 공간, 가용 공간
  - 할당 공간은 프로그램이 이미 할당된 공간
  - 가용 공간(Hole)은 프로그램을 새로 할당할 수 있는 공간
- **Dynamic Storage-Allocation Problem(Size가 n인 요청을 만족하는 가장 적절한 hole을 찾는 문제)**
  - First-fit
    - Size가 n 이상인 것 중 최초로 찾은 hole에 할당
  - Best-fit
    - Size가 n 이상인 가장 작은 hole을 찾아서 할당
    - Hole들의 리스트가 크기 순으로 정렬되지 않은 경우 모든 hole의 리스트를 탐색해야 함
    - 아주 작은 hole들이 많이 생성됨
  - Worst-fit
    - 가장 큰 hole에 할당
    - 모든 리스트를 탐색해야 함
    - 상대적으로 큰 hole들이 생성됨
    - First-fit과 Best-fit보다 속도와 공간 이용률 측면에서 비효율적
- compaction
  - 외부 단편화를 해결하는 한 가지 방법
  - 사용 중인 메모리 영역을 한 군데로 몰고 hole들을 다른 한 곳으로 몰아 큰 block을 만드는 것
  - 매우 비용이 많이 드는 방법
  - 최소한의 메모리 이동이 필요(매우 복잡)
  - 프로세스의 주소가 런타임 바인딩이 가능해야 함

## **불연속 할당**

#### **페이징**

- 프로세스의 가상 메모리를 동일한 사이즈의 페이지 단위로 나눔
- 가상 메모리의 내용이 페이지 단위로 불연속적으로 저장됨
- 일부는 backing storage에, 일부는 물리 메모리에 저장
- 기본 방식
  - 물리 메모리를 동일한 크기의 프레임으로 나눔
  - 논리 메모리를 동일한 크기의 페이지로 나눔(프레임과 같은 크기)
  - 모든 가용 프레임들을 관리
  - 페이지 테이블을 사용하여 논리 주소를 물리 주소로 변환
  - 외부 단편화 발생 안함
  - 내부 단편화 발생 가능
- 페이지 테이블(프로세스 별로 존재)
  - 메인 메모리에 상주
  - Page-table base register(PTBR)가 페이지 테이블을 가리킴
  - Page-table length register(PTLR)가 테이블의 크기를 보관
  - 모든 메모리 접근 연산에는 2번의 memory access가 필요
  - page table 접근 1번, 물리 메모리(data/instruction)접근 1번
  - 속도 향상을 위해 associative register 혹은 translation look-aside buffer(TLB: 고속 하드웨어 캐시) 사용
- 32bit(주소표현방식) 기준으로 2^32Byte(4GB)의 주소 공간
  - 페이지 사이즈가 4KB시 1M개의 페이지 테이블 엔트리가 필요

#### **세그멘테이션**

- 프로세스를 구성하는 단위를 의미 단위(segment)로 쪼갠 것
- 시작위치 + offset(떨어진 정도)
- 페이징은 균일하지만 세그먼트는 균일하지 않아서 offset(얼마나 떨어져있는가)가 중요하다(페이지는 몇 번째인가 정보만으로 충분)
- 세그먼트 테이블로 물리 주소로 변환
- 의미단위로 일할 때 효과적
  - 보안
  - 공유
  - 할당(페이징이 더 효율적)

#### **페이지드 세그멘테이션**

- 세그먼트 하나가 여러 페이지로 쪼개져서 올라감
- 각 세그먼트에 해당하는 페이지 테이블이 존재
- 세그먼트 테이블이 페이지 테이블의 주소를 가리킴.
- 세그먼트 주소 = 시작 위치 + offset(떨어져있는 정도)

**\* 주소 변환은 OS가 끼어들지 않고 하드웨어적인 부분에서 처리가 끝난다.**

**\* OS는 IO관련에서 끼어들음.**
